<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>

    //    js的var变量只有全局作用域和函数作用域两种 !!!

    /*
     函数提升分为两种情况：
     一种：函数申明。就是上面A，function foo(){}这种形式
     另一种：函数表达式。就是上面B，var foo=function(){}这种形式
     第二种形式其实就是var变量的声明定义，因此上面的B输出结果为undefined应该就能理解了。
     而第一种函数申明的形式，在提升的时候，会被整个提升上去，包括函数定义的部分！
     直接在函数体内定义的函数声明，整个都会提前；
     但是在块中定义的函数声明，只会提升其声明部分，不分配实际的内存空间。
     */

    /*要彻底理解JS的作用域和Hoisting，只要记住以下三点即可：
     1、所有申明都会被提升到作用域的最顶上
     2、同一个变量申明只进行一次，并且因此其他申明都会被忽略
     3、函数声明的优先级优于变量申明，且函数声明会连带定义一起被提升*/

    (function () {
        console.log(a); //function a() {}
        // 申明只进行一次，并且函数声明的优先级优于变量申明，所以不是undefined
        var a = 3;
        function a() {
        }
        var a = 4;
        console.log(a);
    })();

    //////////////
    console.log("//////////////");
    //////////////

    (function () {
        console.log(a); //undefined
        var a = 1;
        console.log(a); //1
        if (true) {
            var a = 2;
            console.log(a); //2
        }
        console.log(a); //2
        /*
         上面的输出其实是：1 2 2。
         虽然看起来里面x申明了两次，但上面说了，js的var变量只有全局作用域和函数作用域两种，且申明会被提升，
         因此实际上x只会在最顶上开始的地方申明一次，var x=2的申明会被忽略，仅用于赋值。也就是说上面的代码实际上跟下面是一致的。
         */
    })();


</script>
</body>
</html>